# Chapter3 Lexical Analysis 요약

--------------------------------------------

* 토큰
  * 어휘 분석기(lexical analyzer)는 소스 프로그램을 스캔하고 일반적으로 전달되는 일련의 토큰을 한 번에 하나씩 파서로 출력한다.
  (원시 프로그램을 읽어들여, 토큰이라는 의미있는 문법 단위로 분리)<br/>
  일부 토큰은 토큰 이름만으로 구성될 수 있는 반면, 다른 토큰은 입력에서 발견된 토큰의 특정 인스턴스에 대한 정보를 제공하는 관련 lexical value 를 가질 수도 있다.
<br/><br/>
* 어휘(Lexemes)
  * 어휘 분석기는 토큰을 파서로 반환할 때마다 관련 어휘(토큰이 나타내는 input characters 의 순서)를 가진다.
  <br/><br/>
* 버퍼링
  * 다음 어휘가 어디에서 끝나는지 보기 위해 입력을 미리 스캔해야 하는 경우가 많기 때문에, 일반적으로 어휘 분석기가 입력을 buffer 해야 한다.<br/>
  한 쌍의 버퍼를 주기적으로 사용하고 각 버퍼 내용의 끝을 경고하는 센티넬로 끝내는 것은 입력을 스캔하는 프로세스를 가속화하는 두 가지 기술이다.
  <br/><br/>
* 패턴
  * 각 토큰에는 해당 토큰에 해당하는 어휘를 구성할 수 있는 캐릭터 시퀀스를 설명하는 패턴이 있다.<br/>
  주어진 패턴과 일치하는 단어 또는 문자열의 집합을 언어(language)라고 한다.
<br/><br/>
* 정규 표현식(Regular expression)
  * 이 표현식은 패턴을 설명하는데 일반적으로 사용된다. 정규 표현식은 single characters 의 결합, 연결, Kleene closure 또는,
  임의의 수의 연산자를 사용하여 작성된다.
  <br/><br/>
* Regular Definitions
  * 프로그래밍 언어의 토큰을 설명하는 패턴과 같은 복잡한 언어 집합은 Regular Definitions 에 의해 정의되는 경우가 많은데, 이는 정규 표현식을 위해 각각 하나의 변수를 정의하는 statements 의 순서이다.
  <br/>하나의 변수에 대한 정규식은 이전에 정의된 변수를 그 정규식 안에서 사용할 수 있다.
<br/><br/>
* 확장된 정규 표현식 표기법
  * 패턴을 더 쉽게 표현하기 위해 정규 표현식에서 다수의 추가 연산자가 단축형으로 나타날 수 있다.<br/>
  예를 들어 + 연산자(one-or-more-of), ?(zero-or-one-of), 캐릭터 클래스(캐릭터 중 하나로 구성된 각각의 문자열의 결합)가 있다.
  <br/><br/>
* Transition Diagrams
  * 어휘 분석기(lexical analyzer)의 동작은 종종 Transition Diagrams 으로 설명될 수 있다.<br/>
  이 다이어그램에는 가능한 패턴 중 하나와 일치하는 어휘를 찾는 동안 나타나는 캐릭터의 history에 대한 state가 각각 있다. 한 state 에서 다른 state 로의 화살표 또는 전환이 있으며, 각각의 지시는 어휘 분석기가 state를 변경을 야기하는것이 가능한 다음 입력 캐릭터를 나타낸다.
<br/><br/>
* 유한 오토마타 (Finite Automata)
  이는 states 의 집합 , 입력 캐릭터, states 간의 transitions 뿐만 아니라 start state 및 하나 이상의 허용 state 의 지정을 포함하는 Transition Diagrams의 공식화이다.<br/>
states를 수락하는것은 일부 토큰에 대한 어휘가 발견되었음을 나타낸다. <br/>
Transition Diagrams 과 달리 유한 오토마타는 입력 캐릭터 뿐만 아니라 빈 입력에서도 전환을 할 수 있다.
<br/><br/>
* 결정론적 유한 오토마타
  * DFA는 각 입력 심볼에 대해 각 state 로부터 정확히 하나의 전환을 갖는 특별한 종류의 유한 오토마톤이다. <br/>
또한 빈 입력에 대한 전환도 허용되지 않는다. DFA는 쉽게 시뮬레이션되며 Transition Diagrams 과 유사하게 어휘 분석기를 잘 구현한다.<br/><br/>

* 비결정론적 유한 오토마타
  * DFA가 아닌 오토마타를 비결정론적이라고 한다. NFA는 종종 DFA보다 설계가 쉽다.<br/>
  어휘 분석기의 또 다른 가능한 아키텍처는 입력 문자를 스캔할 때 가능한 각 패턴에 대해 NFA가 있을 수 있는 모든 state 를 표로 만드는 것이다.<br/><br/>
  
* 패턴 표현간의 전환
  * 정규 표현식이 정의하는 것과 동일한 언어를 인식하여 정규 표현식을 거의 동일한 크기의 NFA로 전환할 수 있다.<br/>
  또한, 모든 NFA는 동일한 패턴에 대해 DFA로 변환할 수 있지만 최악의 경우(일반 프로그래밍 언어에서는 결코 접하지 않음) 오토마톤의 크기가 기하급수적으로 커질 수 있다.<br/>
  또한 비결정론적 또는 결정론적 유한 오토마톤을 유한 오토마톤에 의해 인식되는 동일한 언어를 정의하는 정규 표현식으로 전환할 수 있다.<br/><br/>

* Lex(어휘 분석기 생성기)
  * Lex와 Flex를 포함한 소프트웨어 시스템 제품군은 어휘 분석기 생성기이다.<br/>
  사용자는 확장된 정규식 표기법을 사용하여 토큰의 패턴을 지정한다.<br/>
Lex는 이러한 표현식을 어휘 분석기로 변환하는데, 이는 본질적으로 패턴을 인식하는 결정론적 유한 오토마톤이다.<br/><br/>

* 유한 오토마타의 최소화
  * 모든 DFA에 대해 동일한 언어를 허용하는 minimum-state DFA가 존재한다.<br/>
  또한, 주어진 언어에 대한 minimum-state DFA는 다양한 states 에서 주어진 이름을 제외하고 유니크하다.
  