# Chapter7 Run-Time Environments 요약 

--------------------------------------------

* Run-Time Organization
  * 소스 언어에 추상화를 구현하기 위해, 컴파일러는 운영 체제 및 타겟 시스템과 함께 런타임 환경을 만들고 관리한다.<br/>
  런타임 환경에는 객체 코드에 대한 정적 데이터 영역과 컴파일시 생성된 정적 데이터 객체가 있다.<br/>
  타겟 프로그램이 실행될 때 생성되고 파괴되는 객체를 관리하기 위한 동적 스택과 힙 영역도 있다.<br/><br/>

* Control Stack
  * 프로시저 호출 및 반환은 일반적으로 제어 스택이라고 하는 런타임 스택에 의해 관리된다.<br/>
  프로시저가 호출하거나 활성화가 제 시간에 중첩되기 때문에 우리는 스택을 사용할 수 있다.<br/>
  즉, p가 q를 호출한다면, q의 활성화는 p의 활성화 안에 중첩된다.<br/><br/>

* 스택 할당
  * 로컬 변수의 저장소는 런타임 스택에 할당되어 프로시저가 종료될 때 로컬 변수에 액세스할 수 없도록 하거나 필요한 언어에 대해 할당할 수 있다.<br/>
  이러한 언어의 경우, 각 실시간 활성화는 제어 스택에 활성화 레코드(또는 프레임)를 가지고 있으며, 활성화 트리의 루트가 하단에 있고, 스택에 있는 활성화 레코드의 전체 시퀀스는 현재 제어가 존재하는 활성화 트리의 경로에 해당한다.<br/>
  후자의 활성화는 스택의 맨 위에 레코드가 있다.<br/><br/>

* 스택에서 Nonlocal Data에 엑세스 
  * 중첩 프로시저 선언을 허용하지 않는 C와 같은 언어의 경우 변수의 위치는 전역이거나 런타임 스택의 맨 위에 있는 활성화 레코드에서 찾을 수 있다.<br/>
  중첩 프로시저가 있는 언어의 경우 각 활성화 레코드에 추가된 포인터인 액세스 링크를 통해 스택의 Nonlocal Data 에 액세스할 수 있다.<br/>
  원하는 Nonlocal Data 는 해당 활성화 레코드에 대한 액세스 링크 체인을 따라 검색된다.<br/>
  디스플레이는 access links 의 체인에 대한 효율적인 short-cut 대안을 제공하는 access links 와 함께 사용되는 보조 배열이다.<br/><br/>
  
* 힙 관리
  * 힙은 무한히 살 수 있는 데이터나 프로그램이 명시적으로 삭제할 때까지 사용되는 저장소의 일부이다.<br/>
  메모리 관리자는 힙 내의 공간을 할당하고 할당을 해제한다.<br/>
  Garbage collection 힙 내에서 더 이상 사용되지 않는 공간을 찾는다. 따라서 다른 데이터 아이템을 저장하도록 재할당될 수 있다.<br/>
  이것이 필요한 언어의 경우, Garbage collection 는 메모리 관리자의 중요한 서브시스템이다.<br/><br/>
  
* 지역 이용(Exploiting Locality)
  * 메모리 매니저들은 메모리 계층을 잘 활용함으로써 프로그램의 실행 시간에 영향을 줄 수 있다.<br/>
  메모리의 다른 부분에 액세스하는 데 걸리는 시간은 나노초에서 밀리초까지 다양하다.<br/>
  다행히도, 대부분의 프로그램들은 상대적으로 적은 수의 코드를 실행하고 적은 수의 데이터만 만지며 대부분의 시간을 보낸다.<br/>
  프로그램은 동일한 메모리 위치에 곧 다시 액세스할 수 있는 경우 시간 지역성을 가지고 있으며, 가까운 메모리 위치에 곧 액세스할 수 있는 경우 공간 지역성을 가지고 있다.<br/><br/>

* 조각화 줄이기
  * 프로그램이 메모리를 할당하고 할당 해제할 때, 힙은 분열되거나 많은 수의 비연속적인 빈 공간이나 구멍으로 부서질 수 있다.<br/>
  request 를 만족시키는 가장 작은 사용 가능한 구멍 할당하는 best fit strategy 가 경험적으로 잘 작동하는것으로 밝혀졌다.<br/>
  best fit 은 공간 활용도를 향상시키는 경향이 있지만 공간 지역성에는 적합하지 않을 수 있다.<br/>
  조각화는 인접한 구멍을 결합하거나 병합함으로써 줄일 수 있다.<br/><br/>

* 수동 할당 해제
  * 수동 메모리 관리에는 두 가지 일반적인 결함이 있는데, 참조할 수 없는 데이터를 삭제하지 않는 것은 memory-leak error 이고 삭제된 데이터를 참조하는 것은 dangling-pointer-dereference 이다.<br/><br/>
  
* Reachability(도달 가능성)
  * 가비지는 참조하거나 도달할 수 없는 데이터이다.<br/>
  도달할 수 없는 객체를 찾는 두 가지 기본 방법이 있다. 도달 가능한 객체가 도달할 수 없게 변함에 따라 전환을 캐치하거나, 모든 도달 가능한 객체를 주기적으로 찾아 나머지 모든 객체가 도달할 수 없음을 추론한다.<br/><br/>
  
* Reference-Counting Collectors 는 객체에 대한 참조 카운트를 유지한다. 카운트가 0으로 바뀌면 객체에 연결할 수 없게 된다.<br/>
그러한 collectors 는 참조를 유지하는 오버헤드를 초래하고 아마도 참조의 체인을 통해 서로 참조하는 도달할 수 없는 개체로 구성된 "순환적(cyclic)" 가비지를 발견하지 못할 수 있다.<br/><br/>

* Trace-Based Garbage Collectors 는 어떤 포인터도 역참조할 필요 없이 직접 액세스할 수 있는 객체로 구성된 루트 집합부터 시작하여 도달 가능한 개체를 찾기 위해 모든 참조를 반복적으로 검사하거나 추적한다.<br/><br/>

* Mark-and-Sweep Collectors 는 첫 번째 추적 단계에서 도달 가능한 모든 객체를 방문하고 표시한 다음 힙을 스위프하여 도달할 수 없는 객체를 해방한다.<br/><br/>

* Mark-and-Compact Collectors 는 mark-and-sweep 시 향상되며 메모리 조각화를 제거하기 위해 힙에서 도달 가능한 객체를 재배치한다.<br/><br/>

* Copying Collectors 는 추적과 여유 공간 찾기 사이의 종속성을 깨버린다.<br/>
그들은 메모리를 두 개의 반공간인 A와 B로 분할한다.<br/>
할당 요청은 한 반공간(예: A)에서 충족되며, 가비지 콜렉터를 채울때 까지, 도달 가능한 객체를 다른 공간(예: B)으로 복사하고, 반공간 역할을 리버스한다.<br/><br/>

* Incremental Collectors
  * Simple trace-based collector 는 가비지가 수집되는 동안 user program 을 중지한다.<br/>
  Incremental collectors 는 가비지 콜렉터와 mutator 또는 user program 의 동작을 끼워 넣는다.<br/>
  mutator 는 이전에 스캔한 체 내에서 참조를 변경할 수 있기 때문에 증분 도달 가능성 분석을 방해할 수 있다.<br/>
  따라서 Incremental Collectors 는 도달 가능한 객체 집합을 과대평가함으로써 안전하게 작동한다; 모든 "floating garbage"는 next round of collection 에서 수거될 수 있다.<br/><br/>

* Partial Collectors 는 일시 정지도 줄여주며;한 번에 가비지의 부분 집합을 수집한다.<br/>
partial-collection algorithms 으로 가장 잘 알려진 generational garbage collection 은 할당된 시간에 따라 객체를 분할하고 수명이 더 짧은 경향이 있기 때문에 새로 생성된 객체를 더 자주 수집한다.<br/>
대체 알고리즘인 train algorithm 은 cars 이라고 불리는 고정된 길이의 파티션을 사용해서 trains 으로 수집된다.<br/>
각 수집 단계는 처음으로 남은 train 의 처음으로 남은 car 에 적용된다.<br/>
car 가 수집되면 도달 가능한 객체가 다른 차량으로 이동하기 때문에 이 차량에는 쓰레기가 남아있고 열차에서 제거될 수 있다.<br/>
이 두 알고리즘은 generational algorithm 을 younger 객체에 적용하고 train algorithm 을 더 오래된 객체 적용하는 partial collector 를 만드는데 같이 사용될 수 있다.